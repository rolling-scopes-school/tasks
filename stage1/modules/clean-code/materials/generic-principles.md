#### [Stage#1](../../) > [Проект 'Clean Code S1E1'](../) 
# Руководство по качеству кода

- [Зачем?](#Зачем)
- [Общие принципы](#Общие-принципы)
  * [1. DRY — *Don't Repeat Yourself*](#_1-dry-don39t-repeat-yourself)
  * [2. KISS — _keep it short simple / keep it simple, stupid_](#_2-kiss-keep-it-short-simple-keep-it-simple-stupid)
  * [3. YAGNI — _You ain't gonna need it_](#_3-yagni-you-ain39t-gonna-need-it)
  * [4. Комментарии](#_4-Комментарии)
    + [4.1 Отложенные задачи (TODO)](#_41-Отложенные-задачи-todo)
  * [5. Пробелы в конце строки](#_5-Пробелы-в-конце-строки)
  * [6. Именование файлов](#_6-Именование-файлов)
  * [Далее](#Далее)

## Зачем?

Легкоподдерживаемый читаемый код – то, к чему стремится любой опытный разработчик. Это код, который легко читать через 2 месяца, полгода, год и больше после его написания, причём не только автору, но и любому другому программисту. А так как в большинстве случаев код разрабатывается в командах – ваши сокомандники должны иметь возможность легко разбираться в вашем кусочке приложения, не прилагая усилий, чтобы расшифровать написанную логику.

Точно так же и вам будет куда комфортнее разбираться в чужом коде, если он максимально понятно написан и соответствуют единому стилистическому стандарту, принятому в команде.

Но, казалось бы, как правила стилизации кода (например, выбор кавычек `'` или `"` и регистра написания букв) влияют на его удобочитаемость?

Если очень кратко: напрямую.

Чуть длиннее:

Пока вы пишете код в одном стиле, вы привыкаете к этому написанию. Нейроны вашего мозга мгновенно определяют, что за переменной с заглавной буквы скрывается класс, а за словом с маленькой буквы стоит локальная изменяемая переменная. Вы также не испытываете раздражения при виде отличного от вашего стиля написания, а это очень важно. Чтение чужого кода – само по себе не всегда приятное занятие, но если этот код ещё и вызывает раздражение... В общем, в жизни программиста и без того хватает сложностей, потому не стоит создавать себе дополнительных.

Ещё одна причина – единый стандарт экономит время на написание кода. Вы не тратите минуты на раздумья: с какого регистра назвать переменную и какой выбрать стиль написания (н/п, _верблюжьяНотация_ или _ВЕРХНИЙ\_РЕГИСТР_), а на автомате пишете в том стиле, что описан в заранее принятом стандарте.

## Общие принципы

### 1. DRY — *Don't Repeat Yourself*
or **DIE** — _Duplication Is Evil_

_Дублирование – это зло!_

Принцип призывает Вас не повторяться при написании кода. Всё, что Вы пишете в проекте, должно быть определено только один раз.
При несоблюдении этого принципа программист будет вынужден вносить изменения в несколько повторяющихся фрагментов кода, вместо одного. Также дублирующийся код приводит к разрастанию программы, а значит, усложняет ее понимание, читабельность.

<details>
    <summary>
    Хочу знать больше:
    </summary>

**История:**
Принцип был впервые упомянут в книге  [«Программист-прагматик» Эндрю Ханта](https://ideafix.name/wp-content/uploads/stuff/book51.pdf) (1999). Однако ещё до выхода книги в свет он был широкоизвестен и повсеместно применялся. В то же время «Программист-прагматик» точно определил принцип и дал ему имя.

В книге DRY описывается как:

> «Каждый фрагмент знания должен иметь единственное, однозначное,
> надежное представление в системе»,

где «фрагмент знания» можно понимать как функциональный логически завершённый кусок кода вашего приложения или алгоритм.

</details>

**Примеры:**

<details>
	<summary> 
		1. CSS: Группировка селекторов
	</summary>

```css
h1 {
  color: #ff0000;
  font-family: Arial;
}
h2 {
  color: #ff0000;
  font-family: Arial;
}
h3 {
  color: #ff0000;
  font-family: Arial;
}
h4 {
  color: #ff0000;
  font-family: Arial;
}
```

С использованием группировки селекторов CSS этот же код может быть написан так:

```css
h1, h2, h3, h4 {
  color: #ff0000;
  font-family: Arial;
}
```

</details>

<details>
	<summary> 
		2. CSS: Повторяющиеся группы стилей в классы
	</summary>

Если один набор CSS-свойств задает стиль нескольких элементов на странице, то такие элементы обычно объединяют в один CSS-класс:

```css
p {
    margin-bottom: 10px;
    text-indent: 10px;
}

/* Re-used styles */
.quotation {
    font-family: "Helvetica";
    font-style: italic;
    text-indent: 20px;
}

.bold-text {
    font-weight: bold;
}
```

```html
<section>
	<h2 class="bold-text">Жалобная книга</h2>
	<p>
	Лежит она, эта книга, в специально построенной для нее конторке на станции железной дороги. Ключ от конторки «хранится у станционного жандарма», на деле же никакого ключа не нужно, так как конторка всегда отперта. Раскрывайте книгу и читайте:
	</p>
	<p class="quotation">«Милостивый государь! Проба пера!?»<p>
	<p>Под этим нарисована рожица с длинным носом и рожками. Под рожицей написано:</p>	
	<p class="quotation">«Ты картина, я портрет, ты скотина, а я нет. Я — морда твоя».</p>
	<p>«Подъезжая к сией станцыи и глядя на природу в окно, у меня слетела шляпа. И. Ярмонкин».</p>
</section>

```

</details>

<details>
	<summary> 
		3. JS: Циклы
	</summary>

```js
// non DRY code
console.log('corn');
console.log('pita');
console.log('potato');
console.log('tortilla');
```

```js
// DRY code
const chips = ['corn', 'pita', 'potato', 'tortilla'];

for ( let i = 0; i < chips.length; i++) {
    console.log(chips[i]);
}
```
</details>

<details>
	<summary> 
		4. JS: Функции
	</summary>

Дублирующуюся логику удобно выносить в функции.

```js
const today = new Date();
const weekday = today.toLocaleDateString('en-US', {weekday: 'long'});

// non DRY code
if (weekday === 'Sunday' || weekday === 'Saturday' ) {
    console.log(`Today is ${today} so my day plan includes: sleep, eat, rest`);
} else {
    console.log(`Today is ${today} so my day plan includes: work, work, work`);
}

// DRY code
const today = new Date();
const weekday = today.toLocaleDateString('en-US', {weekday: 'long'});

if (weekday === 'Sunday' || weekday === 'Saturday' ) {
    logDayPlan(today, 'sleep, eat, rest');
} else {
    logDayPlan(today, 'work, work, work');
}

function logDayPlan(weekday, tasks) {
    console.log(`Today is ${weekday} so my day plan includes: ${tasks}`);
}
	
```
</details>

### 2. KISS — _keep it short simple / keep it simple, stupid_

_Делайте вещи проще!_

Порой наиболее правильное решение – это наиболее простая реализация задачи, в которой нет ничего лишнего.

Чем проще код, тем легче в нём разобраться, как вам, так и другим людям, занимающимся его поддержкой. Под простотой подразумевается отказ от использования хитроумных приемов и ненужного усложнения.


<details>
    <summary>Примеры:</summary>

В качестве примера нарушения этого принципа можно назвать написание отдельной функции только лишь для осуществления операции сложения или использование побитового оператора (right shift >> 1) для деления целых чисел на 2.

`(4 >> 1) === (4 / 2)` 

Последнее может оказаться более эффективным для некоторых программных компиляторов, чем обычное деление `/ 2`, но при этом очень сильно снижается понятность кода.

> Важное примечание: Для JS движков эффективность операции сдвига нивелируется дорогостоящим приведением к целочисленному – [тут подробнее](https://thefullsnack.com/en/bitwise-javascript-fast.html).

Применяя такой подход, вы осуществляете clever coding («заумный» кодинг) и over-optimization (чрезмерную оптимизацию). И то, и другое в долгосрочной перспективе будет делать ваш код всё менее и менее понятным как другим разработчикам, так и вам самим, ведь, возможно, вам придётся разбираться с этим кодом снова через месяц, два, год.

</details>

<details>
    <summary>Хочу знать больше:</summary>

**История:** 

Принцип проектирования, принятый в военно-морских силах США в 1960. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей и следует избегать ненужной сложности. Фраза ассоциировалась с авиаконструктором Кларенсом Джонсоном (1910—1990). В 1970-х гг. широко использовался термин «KISS-принцип» (англ. KISS principle). Вариации на фразу включают «англ. Keep it Simple, Silly», «keep it short and simple», «keep it simple and straightforward» и «keep it small and simple».

[Ещё больше на Википедии](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF))

</details>

### 3. YAGNI — _You ain't gonna need it_

_Вам это не понадобится!_

Всё, что не предусмотрено заданием проекта, не должно быть в нём.

Проще говоря, вам не стоит писать функциональность наперед, если прямо сейчас в ней нет необходимости. Желание написать код на будущее может иметь много неприятных последствий: 

- Вы тратите драгоценное время, которое могло бы быть использовано на добавление, тестирование и улучшение действительно необходимой функциональности.
- Новые функции должны быть протестированы, задокументированы.
- Ваши ненужные новые функции могут впоследствии помешать добавить новые, но уже нужные.
- Если написанный код в итоге понадобится, он может оказаться неправильным. 
- Лишний код может в итоге никогда и не понадобиться.
- Лишний код усложняет вашу программу (см. KISS).
- Добавление новой ненужной функциональности может привести к желанию добавить ещё больше новой лишней функциональности, приводя к эффекту «снежного кома».

[Мартин Фаулер о YAGNI](https://martinfowler.com/bliki/Yagni.html)

### 4. Комментарии

Поясняйте код при необходимости, где это возможно.

Используйте комментарии для пояснения кода:

- Что он покрывает?
- Какова его задача?
- Почему такое решение используется или предпочтительно?

В то же время не стоит пытаться покрыть комментариями весь код. Использование значимых названий переменных и функций, разбитие кода на логические фрагменты с помощью функции и другие практики помогают сделать код максимально читаемым и понятным не прибегая к комментариям (самодокументирующийся код). 

Тем не менее, бывают случаи, когда поясняющие комментарии нужны, вне зависимости от того, как выглядит ваш код.

Обычно это происходит, когда вам нужно добавить контекст к неинтуитивному решению.


```js
// Not recommended
const MAIN_TEXT_COLOUR = '#000000'; // colour for main text on the page
```
Комментарий тут излишен, так как он поясняет очевидное из названия переменной назначение константы.

А вот хороший пример из библиотеки Lodash:

```js
// Recommended

function addSetEntry(set, value) {   
  // Don't return `set.add`, as this call chain doesn't work in Internet Explorer 11
  set.add(value);    
  return set;  
}

```
[Подробнее о комментариях](https://learn.javascript.ru/comments)

#### 4.1. Отложенные задачи (TODO)
_Частный случай комментариев_

TODO – от англ. *to do* (пер. «сделать») используется для обозначения запланированного изменения прямо в комментариях кода. Обычно эта задача относится к несрочным изменениям, но достаточно важным. Поэтому разработчики прямо в коде оставляют своего рода напоминание себе и другим программистам.

- Впереди такой пометки используйте префикс «ТODO: ...».
- Используйте только данный тип обозначения для TODO-задач.

```js
// TODO: move this magic number (15 rows) to the configuration file
for (let i = 0; i < 15; i++) {
    const row = document.createElement('tr');
    table.appendChild(row);
}
```
```html
<!-- TODO: remove optional tags -->
<ul>
  <li>Apples</li>
  <li>Oranges</li>
</ul>
```

### 5. Пробелы в конце строки

*англ. Trailing whitespaces*

Пробелы в конце строки являются излишними, к тому же они усложняют commit-изменения в Github (вы видите лишнюю строчку/символ изменений, не несущего смыслового изменения):

```html
<!-- Not recommended -->
<p>What?_

<!-- Recommended -->
<p>Yes, please.
```

### 6. Именование файлов

Придерживайтесь единого стиля именования файлов в проекте. Рекомендуем использовать нижний регистр написания с разделением слов дефисом.

Также удобно разделять файлы на `/js`, `/assets`, `/styles` (если иное не указано в тексте задания). Покомпонентная структура папок тоже приемлема (имеется в виду хранение в одной папке всех файлов, относящихся к определённой компоненте). 

```
/assets
	right-arrow-image.svg
	left-arrow-image.svg
/js
	app.js
	image-slider.js
/styles
	basic.css
	image-slider.css
/html	
	index.html
	image-slider.html
``` 

### Далее:
- [HTML и CSS рекомендации – начальный уровень](html-and-css.md)
- [HTML и CSS рекомендации – продвинутый уровень](html-and-css-extended.md)
- [Рекомендации к commit-ам](commits.md)
<!-- – [JavaScript рекомендации](./javascript.md)
- [Автоматизируй это](./automation.md) -->
