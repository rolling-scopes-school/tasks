## Советы по выполнению задания Portfolio#3-Добавление функционала

- [Описание и требования задания Portfolio#3-Добавление функционала](portfolio-part3.md)
- Советы не являются частью задания. Следуйте советам только в той мере, в которой они могут вам помочь.

- [Советы по выполнению задания Portfolio#3-Добавление функционала](#советы-по-выполнению-задания-portfolio3-добавление-функционала)
  - [Смена изображений в секции Portfolio](#смена-изображений-в-секции-portfolio)
  - [Методы поиска элементов](#методы-поиска-элементов)
  - [Шаблонные строки](#шаблонные-строки)
  - [Делегирование](#делегирование)
  - [data-атрибуты](#data-атрибуты)
  - [Кеширование изображений](#кеширование-изображений)
  - [Подсветка активной кнопки](#подсветка-активной-кнопки)
  - [Перевод страницы на два языка](#перевод-страницы-на-два-языка)
  - [Подготовка файлов с переводом](#подготовка-файлов-с-переводом)
  - [JS-modules](#js-modules)
  - [Функция перевода страницы](#функция-перевода-страницы)
  - [Переключение светлой и тёмной темы](#переключение-светлой-и-тёмной-темы)
  - [Дополнительный функционал: данные хранятся в local storage](#дополнительный-функционал-данные-хранятся-в-local-storage)
  - [Дополнительный функционал: сложные эффекты для кнопок](#дополнительный-функционал-сложные-эффекты-для-кнопок)

### Смена изображений в секции Portfolio

JavaScript очень терпим к качеству кода.  
Можно написать совсем простой даже примитивный код, и он будет работать.  
Работоспособный код это достойная уважения цель, но когда она достигнута, можно попробовать написанный код улучшить.

Мы сделаем так: сначала напишем максимально простой, но работоспособный код, а потом посмотрим как его можно улучшить.  
В процессе улучшения (рефакторинга) кода рассмотрим такие вопросы как
- методы поиска элементов
- шаблонные строки
- делегирование событий
- data-атрибуты

Рассмотрим достаточно подробно для того, чтобы вы их хорошо усвоили, и в дальнейшем больше к этим темам не возвращаться.

В секции Portfolio в файле `index.html` есть кнопка и изображение  
```html
<button class="portfolio-btn">Winter</button>

<img src="./assets/img/autumn/1.jpg" alt="portfolio-image" class="portfolio-image">
```  

Посмотрим, как можно изменить изображение, кликом по кнопке.  

Нам нужно:  
1) найти кнопку
2) найти изображение
3) при клике по кнопке изменить `src` изображения, заменив `autumn` на `winter`.  

Код этого волшебства будет выглядеть следующим образом:  
```js
const portfolioBtn = document.querySelector('.portfolio-btn');
const portfolioImage = document.querySelector('.portfolio-image');

portfolioBtn.addEventListener('click', () => {
   portfolioImage.src = "./assets/img/winter/1.jpg"
});
```  
Собственно, всё.  
Правда у нас четыре кнопки и шесть картинок, но, присвоив каждой кнопке и каждой картинке уникальный класс, и повторив этот фрагмент кода 4х6=24 раза, мы сможем добиться поставленной цели.  
Это если бы цель была просто выполнить задание.  
Но так как цель научиться новому, займёмся рефакторингом кода.

### Методы поиска элементов

Для поиска элементов в 90% или даже 99% случаев используются методы `.querySelector()` и `.querySelectorAll()`. Первый позволяет найти один элемент на странице, второй - все, если элементов несколько.

Сравнительно недавно элементы в js искали по `id`. Для стилизации элементов использовали классы, а если предполагалось эти элементы использовать в js, им добавляли ещё и `id`. Поиск элементов по `id` даёт небольшое преимущество в скорости работы. Но использование `id` противоречит методологии БЭМ. Так как уникальный `id` на странице может быть только один, код, написанный с использованием `id` не получится оформить в отдельный модуль и использовать в разных проектах: ведь если в другом проекте уже есть элемент с таким же `id`, код сломается и работать не будет. 

Поэтому сейчас элементы принято искать по их классам. Нет необходимости присваивать элементам одни классы для стилизации, другие для js. Мы добавляем элементу класс, по этому классу элемент стилизуем, и по нему же находим на странице.

**Пример**

Найдём на странице кнопку с классом `portfolio-btn` и запишем результат поиска в переменную `portfolioBtn`  
```js
const portfolioBtn = document.querySelector('.portfolio-btn');
```  

Найдём на странице все изображения с классом `portfolio-image` и запишем результат поиска в переменную `portfolioImages`:  
```js
const portfolioImages = document.querySelectorAll('.portfolio-image');
```  

**Обратите внимание:**

- все переменные, соответствующие элементам, которые есть в коде страницы, объявляются при помощи ключевого слова `const`
- также `const` используется для объявления переменных, которые мы не планируем менять
- ключевое слово `let` используется для объявления переменных, значения которых будут изменяться
- названия переменных - существительные, названия функций - глаголы
- в css используем kebab-case: все буквы маленькие, слова разделяются дефисом
- в js используем camelCase: первая буква всегда маленькая, далее каждое слово начинается с большой буквы

Разница между методами `.querySelector()` и `.querySelectorAll()` не только в том, что первый находит один элемент, а второй несколько.  
- метод `querySelector()` находит отдельный элемент, с которым можно что-то делать
- метод `querySelectorAll()` находит коллекцию элементов NodeList, которую нужно перебирать при помощи метода `forEach()`.

Метод `querySelectorAll()` позволил найти на странице все изображения с классом `portfolio-image`, теперь мы можем изменить `src` у всех картинок сразу:  
```js
portfolioImages.forEach((img, index) => img.src = `./assets/img/winter/${index + 1}.jpg`);
```  
Перебор картинок методом `.forEach()` выглядит чуть сложнее, чем изменение `src` у каждой картинки отдельно, но благодаря ему мы смогли сократить количество кода в шесть раз. А если учесть, что элементов, которые нужно изменить, на странице может быть много, использование этого метода безусловно полезно и с ним очень желательно разобраться.



### Шаблонные строки

Шаблонные строки используются вместо обычных строк в тех случаях, если внутри строки нам необходимо использовать переменную.  
Это действительно очень удобно.  
В предыдущем примере нам необходимо было указать `src` каждого изображения с учётом его индекса. Первое изображение `"./assets/img/winter/1.jpg"`, второе - `"./assets/img/winter/2.jpg"`, шестое - `"./assets/img/winter/6.jpg"`. 

С использованием обычных строк, код выглядел бы так:  
```js
img.src = "./assets/img/winter/" + (index + 1) + ".jpg"
```  
(index + 1) используем потому что `index` начинается с нуля, а нумерация картинок в папке проекта с 1.

В шаблонной строке вместо одинарных или двойных кавычек используются косые кавычки (на клавиатуре находятся на одной клавише с буквой "ё"). Чтобы подставить в шаблонную строку переменную или выражение, заключаем их в фигурные скобки, перед которыми ставим знак доллара - "$".

Шаблонные строки широко используются в современном js, знать о них и использовать их в своём коде, безусловно, полезно.

### Делегирование

Делегирование мы уже использовали, когда скрывали адаптивное меню при клике по любой из ссылок во [второй части задания](portfolio-part2-hints.md#adaptive-menu)  

Так как делегирование - важный и нужный приём разработки, повторим ещё раз этапы работы с ним.  
Чтобы не назначать отдельный слушатель каждому элементу с одинаковым или схожим функционалу:
1. Находим их ближайшего общего родителя
2. Проверяем, что событие произошло на нужном элементе
3. Выполняем функцию

Ближайший общий родитель кнопок с классом `portfolio-btn` - их общий контейнер `portfolio-btns`. Находим его на странице и присваиваем переменной `portfolioBtns`  
```js
const portfolioBtns = document.querySelector('.portfolio-btns');
```  
В функцию `changeImage()`, которую будем выполнять при клике по находящимся внутри `portfolioBtns` кнопкам, добавляем проверку, что целевой элемент `event.target` имеет класс `portfolio-btn`, то есть является кнопкой.  
```js
function changeImage(event) {
  if(event.target.classList.contains('portfolio-btn')) {
    // здесь код функции, меняющей src изображений
  }
}
```  

### data-атрибуты

Код функции `changeImage()`, которая выполняется при кликах по кнопкам, хоть и похожий, но разный. При клике по одной кнопке должны появиться весенние изображения, при клике по другой - зимние.  
Делегирование, которое обсуждали выше, позволяет определить, что пользователь кликнул по кнопке. Но как узнать, что это была за кнопка, и какие изображения нужно отобразить при клике по ней?

Для распознавания элементов в html-коде страницы используются data-атрибуты.  
Название и значение data-атрибутов разработчик определяет сам. Единственное условие: название data-атрибута всегда начинается с префикса data-, дальше идёт любое выбранное вами слово. Например:  
```html
<div class="portfolio-btns">
  <button class="portfolio-btn" data-season="winter">Winter</button>
  <button class="portfolio-btn" data-season="spring">Spring</button>        
  <button class="portfolio-btn" data-season="summer">Summer</button>
  <button class="portfolio-btn" data-season="autumn">Autumn</button>
</div>
```  
Получить data-атрибут элемента можно при помощи `dataset` и ключа - слова, которое в названии атрибута идёт после префикса data-. Для первой кнопки `dataset.season = "winter"`, для второй `dataset.season = "spring"` и так далее.  

В коде функции `changeImage()`, которая выполняется при клике по кнопке, необходимо определить значение `dataset.season` этой кнопки и подставить его в шаблонную строку, определяющую `src` изображения. Благодаря этому при клике по кнопке с data-атрибутом "winter" на странице будут отображаться картинки из папки "winter", а если data-атрибут кнопки "summer", то и картинки будут отображаться из папки "summer".

### Кеширование изображений

После того, как изображение было загружено в браузер, оно добавится в кеш браузера и при следующем использовании будет загружаться намного быстрее.  
В обычной ситуации изображения кешируются, когда их открывает пользователь, но можно кешировать изображения средствами js.  
Всё, что для этого необходимо: сказать браузеру, что у нас есть такая картинка.  
Для этого создаём новое изображение и указываем его src. Так выглядит функция кеширования изображений из папки "summer"  
```js
function preloadSummerImages() {
  for(let i = 1; i <= 6; i++) {
    const img = new Image();
    img.src = `./assets/img/summer/${i}.jpg`;
  }
}
preloadSummerImages();
```  
Самостоятельно напишите функцию `preloadImages()` для кеширования изображений из всех папок с временами года.  
```js
const seasons = ['winter', 'spring', 'summer', 'autumn'];
```  
Вероятно, для перебора элементов массива понадобится метод `.forEach()`, а в шаблонную строку необходимо будет подставить не только переменную с номером изображения, но и переменную с названием папки.

### Подсветка активной кнопки

Подсветка активной кнопки или ссылки - задача, очень часто встречающаяся в разработке.  
Подсветка это просто выделение стилем: цветом, подчёркиванием, фоном и т. д.  
css умеет менять стиль при наведении, но для того, чтобы добавить выделение активному элементу и убрать его у неактивных элементов, понадобится js.  

JavaScript умеет изменять стиль элемента. Например:  
```js
const portfolioBtn = document.querySelector('.portfolio-btn');

portfolioBtn.style.backgroundColor = '#bdae82';
portfolioBtn.style.color = '#000';
```  
Данный код изменил цвет фона кнопки на золотой, а цвет шрифта на черный.  
Но таким образом js используют очень редко. Более распространённый вариант - в css указать класс с нужными свойствами, а в js присвоить его элементу. Примерно так:  
```css
.portfolio-btn.active {
  color: #000;
  background-color: #bdae82;
}
```  
```js
portfolioBtn.classList.add('active');
```  
Такой подход предпочтительней по нескольким причинам. Во-первых, сокращается количество кода: добавлять и удалять классы проще и быстрее, чем стили. которых может быть много. Например, активной кнопке нужно указать изменение цвета шрифта при наведении, могут меняться и другие свойства. И для изменения каждого из этих свойств нужно будет писать js-код, а когда дизайнер внесёт правки, переписывать его. Во-вторых, соблюдается принцип разделения ответственности, когда в html-файле пишем только разметку, в css-файле - только стили, в js-файле - только функционал.

Рассмотрим как при помощи js подсвечивается активная кнопка.

Последовательность действий следующая:  
1. В файл `style.css` добавить класс `active` для активной кнопки и указать его стили. 

Дальше работаем в файле `index.js`. Нам нужно:  
1. Найти все кнопки используя метод `querySelectorAll()`
2. Убрать у всех кнопок класс `active`
3. Кнопке, на которой произошёл клик - `event.target` - добавить класс `active`

Изменение стиля активного элемента - одна из часто встречающихся задач. Даже в нашем небольшом проекте этот функционал повторяется минимум дважды: при клике по кнопкам смены изображений и при клике по символам `"en"`, `"ru"` на панели смены языка.

Повторяющиеся фрагменты кода выносятся в функции.  

Напишите функцию `changeClassActive()`, которая принимает в качестве параметра название класса, и добавляет класс `active` элементу, на котором произошло событие. 

### Перевод страницы на два языка

Перевод приложения или интернационализация - задача, часто встречающаяся в разработке.  
Для длинного слова `internationalization` часто используют сокращение `i18n` - `i`, затем ещё 18 букв, затем `n`.  

### Подготовка файлов с переводом

При переводе текста страницы наиболее трудоёмкий и длительный подготовительный этап: подготовка файла с переводом и прописывание data-атрибутов для элементов, которые необходимо перевести. При этом непосредственно перевод - это всего несколько строк js-кода.

Часть работы для вас уже выполнили и файл с переводом подготовили.  
Для перевода можно воспользоваться файлом [translate.js](https://github.com/rolling-scopes-school/file-storage/blob/portfolio/translate.js)  
Вы можете воспользоваться предложенным файлом с переводом или создать свой собственный.

Если хотите выполнить перевод полностью самостоятельно, в файле `index.html` находите все элементы внутри которых есть какой-нибудь текст и добавляете им data-атрибут.  
Название data-атрибута произвольное, например, `data-i18n`, значение data-атрибута тоже произвольное, желательно более-менее осмысленное, чтобы можно было догадаться о каком элементе речь.

Параллельно с добавлением элементам атрибутов заполняете файл [translate.js](https://github.com/rolling-scopes-school/file-storage/blob/portfolio/translate.js).  

Если планируете использовать предложенный файл [translate.js](https://github.com/rolling-scopes-school/file-storage/blob/portfolio/translate.js), достаточно в файле `index.html` добавить элементам data-атрибуты, указывая им то значение, которое используется в файле с переводом.

Например, в файле `index.html` у элемента значение data-атрибута `"skill-text-1"`  
```html
<div class="skill-text" data-i18="skill-text-1">
  High-quality photos in the studio and on the nature
</div>
```  
В файле с переводом для этого элемента указаны такие свойства  
```js
const i18Obj = {
  'en': {
    'skill-text-1': 'High-quality photos in the studio and on the nature'
  },
  'ru' : {
    'skill-text-1': 'Высококачественные фото в студии и на природе'
  }
}
```  
В предложенном примере, так как текста для перевода совсем мало, у нас только один файл с переводом. Внутри него объект, внутри которого ещё два объекта с ключами `"en"` и `"ru"`, внутри каждого из них список свойств в формате ключ-значение, где ключ - это значение data-атрибута элемента, а значение - текст, который внутри этого элемента находится.  

Если необходимо перевести большое количество текста, удобнее для каждого языка создать отдельный файл с переводом.

Файл с переводом вы создали, как его использовать?  
Самый простой, хоть и не самый удобный вариант - скопировать содержащийся в файле объект `i18Obj` и вставить его в верхнюю часть файла `index.js`.  
Если вы выбираете такой вариант, следующий раздел про модули в js можно пропустить, для stage#0 он может быть слишком сложным. Прочитаете когда-нибудь позже.

### JS-modules

Особенности js-модулей рассматриваются в небольшом 10-минутном видео [Модули в JavaScript](https://youtu.be/VtEwDiC5npA)

**Подключение js-модулей к проекту**.  
Есть один общий js-файл index.js с типом `type="module"` и только он один подключается к html:
```html
<script type="module" src="index.js"></script>
```
Остальные js-файлы импортируются(подключаются) в index.js.  
Такой модульный подход будет работать только на сервере. Live Server, который есть в VS Code, вполне подойдёт.  

Если в подключаемом js-файле есть только одна функция, которую нужно экспортировать, для её экспорта используем директиву `export default`
```js
// translate.js
export default i18Obj;
``` 
Импорт в index.js в этом случае выглядит так:  
```js
// index.js
import i18Obj from './translate.js';
```  
Если файл translate.js лежит в папке js, меняется только путь импорта:  
```js
// index.js
import i18Obj from './js/translate.js';
```  

Кстати, про пути.  
Когда обсуждали пути в [советах](https://github.com/rolling-scopes-school/tasks/blob/master/tasks/cv/cv-stage0-hints.md#пути) к таску CV#3, говорили, что оба пути 'translate.js' и './translate.js' равнозначные и рабочие. Это утверждение справедливо для подключения файла, но в случае импорта работает только второй вариант.

Всё, что касалось данного задания уже закончилось, дальше информация на будущее.

Если в подключаемом js-файле много функций, которые нужно экспортировать, перед каждой пишем директиву `export `
```js
// gallery.js
export function fn1() {...} 
export function fn2() {...}
``` 
Импорт в index.js в этом случае выглядит так
```js
// index.js
import * as galleryFn from  './js/gallery.js';
```  
Использовать подключенные таким образом функции можно так
```js
// index.js
import * as galleryFn from  './js/gallery.js';

galleryFn.fn1();
galleryFn.fn2();
```

### Функция перевода страницы

Саму функцию перевода `getTranslate()` можно написать буквально в две строчки:
- параметром функции указываем язык, на который нужно перевести страницу, в нашем случае английский или русский
- в теле функции находим все элементы, содержащие data-атрибут `[data-i18]`
- перебираем полученную коллекцию NodeList при помощи метода `forEach()`
- далее можно сделать две проверки: 
  1. На соответствие ключей в объекте i18Obj с data-атрибутами из коллекции
  2. Проверить, если в текущий момент перебираемый элемент имеет placeholder, тогда присвоить ему placeholder со значением ключа из объекта. Например:
      ```js
        if (currentEelement.placeholder) {
          currentEelement.placeholder = // Ваш код
          currEelem.textContent = ''
        }
      ``` 
- для каждого элемента указываем текстовое содержание - `textContent` - значение соответствующего этому элементу свойства объекта `i18Obj`
- Подсказка. Язык перевода это аргумент, с которым вызывается функция `getTranslate()`. Ключ по которому получаем значение - `dataset.i18`  

### Переключение светлой и тёмной темы

Из двух вариантов светлой темы выбираете тот, который больше нравится.  
- [Макет в figma - светлая тема - 1](https://www.figma.com/file/tbs0GYhOle1nLWvgnI7AzZ/Portfolio-white-1)
- [Макет в figma - светлая тема - 2](https://www.figma.com/file/bpSokvEmZajiWZKs9cpNJi/Portfolio-white-2)

Первый вариант проще в реализации. В нём блоки и секции `header`, `hero`, `contacts`, `footer` остались без изменений, в оставшихся секциях цвет фона и шрифта поменялись местами: фон стал белым, шрифт черным.

То есть всё, что от нас требуется, указать белый фон черный шрифт для секций 
  - `skills`
  - `portfolio`
  - `video`
  - `price`  

Кроме того, для кнопок с прозрачным фоном секции `portfolio` нужно указать черный цвет шрифта при наведении.

Выше обсуждали, что менять css-стили при помощи js в принципе можно, но это не оптимальный вариант.

Более предпочтительный способ в css указать свойства класса `.light-theme` (название условное) с примерно такими свойствами:  
```css
.light-theme {
  background-color: #fff;
  color: #000;
}

.light-theme:hover {
  color: #000;
}
```  
В js создаём массив с названиями классов всех элементов, стили которых меняются при переключении темы.

При помощи метода `forEach()` перебираем эти элементы и при переключении на светлую тему добавляем им класс `.light-theme`, при переключении на тёмную тему этот класс убираем, используя метод `classList.toggle()`.

Также переключать светлую и тёмную тему можно изменяя значения css-переменных.  
Например, в css переменные указываются через `:root`  
```css
:root {
  --body-color: #000;
  --text-color: #fff;
  --hover-color: #fff;
}
```  
В js меняем значения переменных
```js
document.documentElement.style.setProperty('--body-color', '#fff');
document.documentElement.style.setProperty('--text-color', '#000');
document.documentElement.style.setProperty('--hover-color', '#000');
```

### Дополнительный функционал: данные хранятся в local storage

Хорошая практика - сохранить выбранные пользователем настройки в локальном хранилище браузера - `local storage`.  
В нашем приложении такими настройками являются язык отображения страницы и светлая или тёмная тема.  
Для того, чтобы их сохранить, нам нужно знать, какая настройка и какая тема выбраны пользователем в данный момент.  
Для этого создадим две глобальные переменные `lang` и `theme` и присвоим им свойства по умолчанию `en` и `light`. Так как мы планируем, что переменные будут меняться, для их объявления используем ключевое слово `let`.  
При смене языка отображения страницы меняем значение переменной `lang`: `en` меняется на `ru`, при смене темы меняем значение переменной `theme`: `light` меняется на `dark`

Эти переменные нужно сохранить в `local storage`.  

Работа с `local storage` состоит из двух частей. 
1) сохранение данных  

Могут быть два варианта: сохранять переменную при каждом её изменении, или сохранить данные только перед перезагрузкой или закрытием страницы (событие `beforeunload`)  
Например:  
```js
function setLocalStorage() {
  localStorage.setItem('lang', lang);
}
window.addEventListener('beforeunload', setLocalStorage)
```
2) перед загрузкой страницы (событие `load`) данные нужно восстановить и отобразить
```js
function getLocalStorage() {
  if(localStorage.getItem('lang')) {
    const lang = localStorage.getItem('lang');
    getTranslate(lang);
  }
}
window.addEventListener('load', getLocalStorage)
```
Пояснения к коду:
- `window` - объект окна браузера, с ним связана загрузка и перезагрузка страницы  
- `addEventListener` - метод, который отлавливает событие элемента и выполняет переданную функцию
- `localStorage.setItem` - метод сохраняющий данные в `localStorage`. Два параметра метода: имя значения, которое сохраняется и само значение, которое сохраняется 
- `localStorage.getItem` - метод получающий данные из `localStorage`. Параметр метода - имя, под которым сохраняется значение.

Чтобы увидеть сохранённые в браузере данные `localStorage`, на странице приложения нажмите клавишу F12, на панели `devTools` вверху выберите пункт `Application`, на боковой панели пункт `Local Storage` и ссылку на страницу приложения.

Обратите внимание: данные в `localStorage` сохраняются в текстовом формате, например, если мы попытаемся сохранить в  `localStorage` булевы значения `true`, `false`, вместо них `localStorage` вернёт строки `"true"` и `"false"`.

### Дополнительный функционал: сложные эффекты для кнопок

Этот пункт предложен в качестве бонуса для того, чтобы вы познакомились с таким замечательным ресурсом как [codepen](https://codepen.io/), где можно найти много примеров оригинальной и интересной реализации отдельных элементов.

С 2013 года ресурс представляет обзоры самых популярных работ [пример](https://codepen.io/2020/popular/pens)  
Также вы можете собирать свою собственную коллекцию понравившихся пенов в закладках браузера или в репозитории на гитхаб [пример](https://github.com/aai210/Best-on-CodePen)
