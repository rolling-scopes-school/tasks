## Советы по выполнению задания Portfolio#2-Адаптивная вёрстка

- [Описание и требования задания Portfolio#2-Адаптивная вёрстка](portfolio-part2.md)
- Советы не являются частью задания. Следуйте советам только в той мере, в которой они могут вам помочь

1. [Adaptive Design](#adaptive-design)
2. [Metateg viewport](#metateg-viewport)
3. [Media Queries](#media-queries)
4. [CSS variables](#css-variables)
5. [calc()](#calc)
6. [Adaptive menu](#adaptive-menu)
7. [Adaptive background image](#adaptive-background-image)

### Adaptive Design

Адаптивная вёрстка позволяет сайту хорошо выглядеть при любом разрешении экрана.  
Основное требование к адаптивной вёрстке - оптимальные размер и расположение элементов, и отсутствие на сайте горизонтальной полосы прокрутки вне зависимости от того, просматривают его на десктопе, планшете или мобильном устройстве.

Для адаптивного сайта дизайнер отрисовывает несколько макетов страницы для компьютеров, планшетов и смартфонов. Разработчик при вёрстке указывает для каждого макета разрешение экрана и задаёт соответствующие ему размеры элементов и отступы между ними. Когда пользователь заходит на сайт, он видит только тот интерфейс, который соответствует ширине экрана его устройства.

Другим способом обеспечить правильное отображение страницы на разных устройствах является респонсивный (резиновый) дизайн, при котором размеры задают в процентах от ширины экрана. При респонсивном дизайне уменьшении ширины страницы сопровождается плавным изменением размеров элементов.

Как правило, в разработке совмещают оба эти подхода: при изменении ширины страницы какие-то элементы изменяются плавно, другие скачкообразно.

### Metateg viewport

В тег <head> html-кода необходимо вложить метатег viewport (при создании основы html-файла VS Code его добавляет автоматически)

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

В этой строке мы указываем, что ширина видимой области равна ширине устройства, а изначального масштабирования нет. Чаще всего это оптимальный сценарий работы страницы.

### Media Queries

Адаптивная вёрстка достигается при помощи медиазапросов. Медиазапросы позволяют определять внешний вид веб-страниц в зависимости от ширины окна браузера.

При помощи медиа-запросов можно создавать так называемые контрольные точки (англ. breakpoints) и привязывать к ним CSS-стили.

Если речь о подходе `Desktop-First`, который реализуется в данном макете, в нём стили пишутся от большего к меньшему. Используются медиазапросы, в которых указывается максимальная ширина экрана, к которой применяются указанные стили:

```css
@media (max-width: 1440px) {
  .skills-items {
    justify-content: space-around;
  }
}
```

Код выше означает, что при ширине экрана до 1440px элементы внутри блока `skills-items` размещаются с равными отступами между собой и краями контейнера. В предыдущей части советов писали о том, что при ширине экрана большей 1440px в данном блоке размещение вложенных элементов управляется свойством `justify-content: space-between` - вложенные элементы прижаты к краям родителя.

В медиазапросах указываем только те свойства элементов, которые изменились для указанной ширины экрана.

Чаще всего в медиазапросах изменяются:

- количество колонок
- размеры элементов
- отступы
- размер шрифта
- отдельные элементы могут скрываться
- добавляется адаптивное меню

### CSS variables

Если в css-коде страницы вы использовали css-переменные, их будет удобно и быстро изменить при помощи медиа-запросов. Вместо того, чтобы изменять значения отступов или размер шрифта каждого элемента, достаточно один раз его изменить в псевдоклассе `:root`.  
Например (здесь и дальше все числа произвольные):

```css
:root {
  --font1: 80px;
  --padding: 75px;
}
@media (max-width: 1024px) {
  :root {
    --font1: 50px;
    --padding: 60px;
}
@media (max-width: 796px) {
  :root {
    --font1: 40px;
    --padding: 40px;
  }
}
```

### calc()

Функция calc() позволяет рассчитать значения css-свойств. При адаптивной вёрстке использование функции calc() позволяет обеспечить плавное изменение размеров элементов при изменении ширины страницы, совместить адаптивный и респонсивный дизайн.  
Например:

```css
.container {
  width: calc(100% - 40px);
}
```

В примере выше ширина контейнера рассчитывается как 100% ширины родительского элемента минус отступы по 20рх по бокам.

### Adaptive menu

Адаптивное меню ещё называют бургер-меню из-за иконки-гамбургера при клике по которой оно открывается и закрывается.

Иконку-гамбургер, как правило, добавляют не как изображение, а верстают при помощи css.  
[Примеры анимированных гамбургер-иконок с codepen](https://codepen.io/RRoberts/full/ZBYaJr)

Эта иконка присутствует в html-разметке не только на мобильных, но и на десктопных разрешениях, но там она скрыта свойством `display: none;`. А когда экран становится уже и все пункты меню в него перестают помещаться, необходимо навигацию спрятать всё тем же свойством `display: none`, а гамбургер, наоборот, отобразить свойством `display: block` или `display: flex`.

Пока ничего сложного не было. Следующий шаг - для указанных в макете разрешений изменить стили адаптивного меню, чтобы в открытом виде оно выглядело так, как на макете. Указать ширину и высоту, свойством `flex-direction: column` выстроить пункты меню в колонку, добавить оформление.

Чтобы меню плавно выезжало сбоку, указываем ему абсолютное позиционирование, значение z-index, чтобы меню располагалось поверх остальных элементов и положение по горизонтали за границей экрана. Если, например, ширина адаптивного меню 620рх, свойство `right: -620px;` разместит его за правой границей экрана. Чтобы при этом не появилась полоса прокрутки, контейнеру, внутри которого размещается меню, указываем свойство `overflow-x: hidden;`. Чтобы меню появилось, достаточно классу `open` указать свойство `right: 0;`, а чтобы появление происходило плавно, используем свойство `transition: 0.5s`.

Последний пункт - кликом по иконке-гамбургеру добавлять или удалять адаптивному меню класс `open` и изменять вид самой иконки.

Открытие и закрытие адаптивного меню можно реализовать и без js, только средствами css, но такое меню сложнее в реализации.  
[Пример адаптивного меню на чистом css](https://codepen.io/Joanc/full/XYYZdE)

Программирование - борьба со сложностью.  
То, что средствами css занимает десятки строк, средствами js требует существенно меньше кода, причём кода понятного и простого.

Для добавления или удаления у адаптивного меню класса `open` идеально подойдёт метод `classList.toggle()`. Если класс у элемента отсутствует, метод `classList.toggle()` этот класс добавляет, иначе - убирает.

Таким образом, js-код для открытия и закрытия адаптивного меню состоит буквально из нескольких строчек:

- при помощи метода `document.querySelector()` находим на странице иконку-гамбургер и адаптивное меню
- отслеживаем клики по иконке при помощи метода `.addEventListener()`
- пишем код функции, которая меняет класс `'open'` у иконки и меню - добавляет, если класса нет и убирает, если класс есть
- в css нужно прописать разные стили для иконки и меню в зависимости от того есть у них класс `'open'` или этого класса нет

По [ссылке](https://codepen.io/irinainina/pen/Jjryqav) можно посмотреть js-код, переключающий класс гамбургер иконки при клике. Весь код поместился в шесть строчек. Вам нужно разобрать и понять его и написать аналогичный код, который будет отображать и скрывать адаптивное меню.

И самый-самый последний пункт - обеспечить скрытие адаптивного меню при клике по ссылке.

Метод `classList.toggle()` в данном случае не подойдёт: нам нужно не переключать, а удалять класс. Для этого используем метод `classList.remove()`. На будущее, ещё есть метод `classList.add()`, который добавляет класс и метод `classList.contains()`, проверяющий наличие класса.  
В скобках внутри этих методов в кавычках пишем название класса. Обратите внимание, так как методы `classList` работают только с классами, при их использовании точка перед названием класса не ставится.

Напишите функцию `closeMenu()`, которая будет удалять класс `'open'` у гамбургер-иконки и меню.

Функцию `closeMenu()` необходимо вызывать при клике по каждой из ссылок меню.

Рабочий, но не оптимальный метод - добавить слушатель каждой ссылке меню.  
Для этого находим все ссылки меню и присваиваем их переменной `navLinks`.  
Чтобы найти несколько элементов, используем метод `querySelectorAll()`.

```js
const navLinks = document.querySelectorAll('.nav-link');
```

Метод `querySelectorAll()` возвращает коллекцию NodeList. NodeList не является массивом, но его элементы можно перебрать при помощи метода `forEach()`

```js
navLinks.forEach((el) => el.addEventListener('click', closeMenu));
```

В коде выше мы добавили слушатель событий на каждую ссылку меню. Можно обойтись только одним слушателем, который добавляем их общему родителю.

```js
nav.addEventListener('click', closeMenu);
```

Чтобы меню закрывалось только при клике по ссылке, добавляем условие

```js
function closeMenu(event) {
  if (event.target.classList.contains('nav-link')) {
    // здесь код, удаляющий класс `'open'` у гамбургер-иконки и у меню
  }
}
```

Параметр `event` (название может быть любым) функции `closeMenu` содержит всю информацию о событии, которое произошло. `event.target` - элемент, на котором произошло событие. Если этот элемент содержит класс `'nav-link'`, значит, клик произошёл по ссылке и нужно закрыть меню.

Метод, когда обработчик событий добавляется не каждому элементу, а их общему родителю, называется делегированием событий. Делегирование - один из самых важных приёмов разработки, так как позволяет отслеживать события на множестве элементов с помощью только одного обработчика.

### Adaptive background image

Сделать адаптив фоновых изображений можно несколькими способами. Во-первых изменять масштаб и позиционирование изображения с помощью свойств `background-size` и `background-position`:
  ```css
  .hero {
    height: 910px;
    background-image: url('../img/bg.jpg');
    background-repeat: no-repeat;
  
    @media (max-width: 768px) {
      height: 590px;
      background-position: -5px -30px;
      background-size: auto 620px;
    }
  }
  ```
Во-вторых, если первый метод не подходит или трудно выполним, можно скачать из макета фоновое изображение для нужного разрешения и устанавливать его как фон в нужных медиа-запросах.
  ```css
  .hero {
    height: 910px;
    background-image: url('../img/bg.jpg');
    background-repeat: no-repeat;
  
    @media (max-width: 768px) {
      height: 590px;
      background-image: url('../img/bg-small.jpg');
    }
  }
  ```
