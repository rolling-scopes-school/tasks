## Советы по выполнению задания Momentum
- [ссылка на задание](momentum-stage1.md)

### 2. Приветствие
#### Текст приветствия изменяется в зависимости от времени суток
Декомпозиция пункта требований:
1. Найти элемент, внутри которого выводится текст приветствия
2. Определить текущее время в часах
3. Определить текущее время суток
4. Сгенерировать приветствие в зависимости от времени суток
5. Создать функцию `showGreeting()`, которая будет отображать приветствие внутри указанного элемента
6. Обеспечить обновление созданной функции

Реализация пункта требований:
1. Методы поиска элемента мы уже рассмотрели
2. Текущее время в часах возвращает метод `getHours()`
```js
const date = new Date();
const hours = date.getHours();
console.log(hours);
```
3. Функцию `getTimeOfDay()`, возвращающую время суток (morning, day, evening, night) в зависимости от текущего времени в часах вам предстоит написать самостоятельно.  
Написать такую функцию можно разными способами: используя опретор `if... else`, или оператор `switch`, или создать массив с названиями времён суток и в зависимости от того, какое целое число получается при делении текущего времени суток на 6, возвращать соответствующий элемент массива.  
Если сомневаетесь какой подход выбрать, отталкивайтесь от того, что преимущество у наиболее простых, лакончиных и понятных решений. При этом не стремитесь к преждевременной оптимизации: можно использовать любой подход, решающий поставленную задачу.

4. Для генерации приветствия удобно использовать [шаблонные строки](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)  
Шаблонная строка выглядит почти так же как обычная строка с небольшими отличиями:  
1. шаблонная строка берётся в косые кавычки  
2. внутрь шаблонной строки можно помещать переменные, взяв их в фигурные скобки и указав знак доллара перед первой скобкой.

**Пример**
```js
const timeOfDay = getTimeOfDay();
const greetingText = `Good ${timeOfDay}`;
```
5. Шаблонная строка возвращает обычный текст, который можно отобразить внутри указанного элемента при помощи метода `textContent()`
6. Обновление приветствия происходит так же, как обновление даты - вызов функции `showGreeting()` помещаем внутрь функции `showTime()` 

#### Пользователь может ввести своё имя
Если вы воспользовались предложенной вёрсткой, данное требование в ней уже выполняется, никаких дополнительных усилий для его реализации предпринимать не нужно. 

В рамках работы над данным пунктом требований было бы полезно познакомиться с интересным и разнообразным элементом [&lt;input&gt;](https://developer.mozilla.org/ru/docs/Web/HTML/Element/Input), разобраться с особенностями получения и изменения его значения.

Элемент `<input>` имеет больше 20 разных типов. Каждый из них предназначен для решения определённой задачи. В приложении используется пожалуй наиболее распространённый `<input>` с типом текст: `type="text"`. Но есть и другие типы элемента `<input>`, никак не связанные с вводом текста. Например: 
- `color` - палитра для выбора цвета;
- `file` - загрузка файлов;
- `radio` - кнопка-переключатель;
- `range` - ползунок для изменения значения.

Так как не все элементы `<input>` связаны с текстом, уже известное нам свойство `textContent` для элемента `<input>` не работает. Вместо него используется удобное свойство `input.value` при помощи которого можно получить и указать значение `<input>`.

#### При перезагрузке страницы приложения имя пользователя сохраняется
Для сохранения имени пользователя используем хранилище браузера - `local storage`.

Работа с `local storage` состоит из двух частей. 
1) перед перезагрузкой или закрытием страницы (событие `beforeunload`) данные нужно сохранить
```js
function setLocalStorage() {
  localStorage.setItem('name', name.value);
}
window.addEventListener('beforeunload', setLocalStorage)
```
2) перед загрузкой страницы (событие `load`) данные нужно восстановить и отобразить
```js
function getLocalStorage() {
  if(localStorage.getItem('name')) {
    name.value = localStorage.getItem('name');
  }
}
window.addEventListener('load', getLocalStorage)
```
Пояснения к коду:
- `window` - объект окна браузера, с ним связана загрузка и перезагрузка страницы  
- `addEventListener` - метод, который отлавливает событие элемента и выполняет переданную функцию
- `localStorage.setItem` - метод сохраняющий данные в `localStorage`. Два параметра метода: имя значения, которое сохраняется и само значение, которое сохраняется 
- `localStorage.getItem` - метод получающий данные из `localStorage`. Параметр метода - имя, под которым сохраняется значение.

Чтобы увидеть сохранённые в браузере данные `localStorage`, на странице приложения нажмите клавишу F12, на панели `devTools` вверху выберите пункт `Application`, на боковой панели пункт `Local Storage` и ссылку на страницу приложения.

Обратите внимание: данные в `localStorage` сохраняются в текстовом формате, например, вместо `true`, `false`, `localStorage` вернёт `"true"` и `"false"`.

#### Метод addEventListener()
В предыдущем разделе, чтобы выполнить код только после того, как изображение загрузилось, мы использовали метод `addEventListener()`. Это важный метод регистрации событий. 

Событие – это сигнал от браузера о том, что что-то произошло.  
Существует много видов событий. Перечислим некоторые из них (запоминать события не нужно).

**События мыши**:
- `click` – клик
- `contextmenu` – клик правой кнопкой мыши
- `dbclick` – двойной клик
- `mouseover` – навели курсор
- `mouseout` – убрали курсор
- `mousedown` и `mouseup` – кнопку мыши нажали или отжали
- `mousemove` – движение мыши

**События клавиатуры**:
- `keydown` – кнопка нажата
- `keyup` – кнопка отжата
- `keypress` – кнопка удерживается

**События на элементах управления**:
- `focus` – элемент в фокусе, например, пользователь нажимает на input или в текстовое поле вводит текст
- `blur` – убрали мышку из фокуса
- `reset` – форма очищена
- `submit` – форма отправлена

И все эти события можно отлавливать.

Метод `addEventListener()` отлавливает событие элемента и выполняет переданную функцию.
Его синтаксис:
```js
element.addEventListener('click', () => {
  // code
});
```
- `element` – элемент на котором отлавливаем события;
- `addEventListener()` – метод отлова событий;
- `click` – какое именно событие отлавливаем (в данном случае 'клик');
- `() => {}` – функция, которая будет выполнена в тот момент, когда событие произойдёт.

Функцию, которая выполняется при наступлении события, лучше создавать отдельно, а внутри метода `addEventListener()` только указывать какая именно функция будет выполняться при наступлении данного события. 
```js
element.addEventListener('click', function);
```
Обратите внимание: внутри `addEventListener()` только указываем функцию `function`, а не вызываем её `function()`

#### Ключевые навыки, которые вы приобрели:
- использование шаблонных строк
- особенности элемента `<input>`
- работа с `localStorage`
- метод `addEventListener()`