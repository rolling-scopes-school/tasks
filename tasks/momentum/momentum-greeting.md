## Советы по выполнению задания Momentum

- [ссылка на задание](momentum-stage1.md)

### 2. Приветствие

#### Текст приветствия изменяется в зависимости от времени суток

Декомпозиция пункта требований:

1. Найти элемент, внутри которого выводится текст приветствия
2. Определить текущее время в часах
3. Определить текущее время суток
4. Сгенерировать приветствие в зависимости от времени суток
5. Создать функцию `showGreeting()`, которая будет отображать приветствие внутри указанного элемента
6. Обеспечить обновление созданной функции

Реализация пункта требований:

1. Методы поиска элемента мы уже рассмотрели
2. Текущее время в часах возвращает метод `getHours()`

```js
const date = new Date();
const hours = date.getHours();
console.log(hours);
```

3. Функцию `getTimeOfDay()`, возвращающую время суток (morning, afternoon, evening, night) в зависимости от текущего времени в часах вам предстоит написать самостоятельно.  
   Написать такую функцию можно разными способами: используя опретор `if... else`, или оператор `switch`, или создать массив с названиями времён суток и в зависимости от того, какое целое число получается при делении текущего времени суток на 6, возвращать соответствующий элемент массива.  
   Если сомневаетесь какой подход выбрать, отталкивайтесь от того, что преимущество у наиболее простых, лакончиных и понятных решений. При этом не стремитесь к преждевременной оптимизации: можно использовать любой подход, решающий поставленную задачу.

4. Для генерации приветствия удобно использовать [шаблонные строки](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)  
   Шаблонная строка выглядит почти так же как обычная строка с небольшими отличиями:
5. шаблонная строка берётся в косые кавычки
6. внутрь шаблонной строки можно помещать переменные, взяв их в фигурные скобки и указав знак доллара перед первой скобкой.

**Пример**

```js
const timeOfDay = getTimeOfDay();
const greetingText = `Good ${timeOfDay}`;
```

5. Шаблонная строка возвращает обычный текст, который можно отобразить внутри указанного элемента при помощи метода `textContent()`
6. Обновление приветствия происходит так же, как обновление даты - вызов функции `showGreeting()` помещаем внутрь функции `showTime()`

#### Пользователь может ввести своё имя

Если вы воспользовались предложенной вёрсткой, данное требование в ней уже выполняется, никаких дополнительных усилий для его реализации предпринимать не нужно.

В рамках работы над данным пунктом требований было бы полезно познакомиться с интересным и разнообразным элементом [&lt;input&gt;](https://developer.mozilla.org/ru/docs/Web/HTML/Element/Input), разобраться с особенностями получения и изменения его значения.

Элемент `<input>` имеет больше 20 разных типов. Каждый из них предназначен для решения определённой задачи. В приложении используется пожалуй наиболее распространённый `<input>` с типом текст: `type="text"`. Но есть и другие типы элемента `<input>`, никак не связанные с вводом текста. Например:

- `color` - палитра для выбора цвета;
- `file` - загрузка файлов;
- `radio` - кнопка-переключатель;
- `range` - ползунок для изменения значения.

Так как не все элементы `<input>` связаны с текстом, уже известное нам свойство `textContent` для элемента `<input>` не работает. Вместо него используется удобное свойство `input.value` при помощи которого можно получить и указать значение `<input>`.

#### При перезагрузке страницы приложения имя пользователя сохраняется

Для сохранения имени пользователя используем хранилище браузера - `local storage`.

Работа с `local storage` состоит из двух частей.

1. перед перезагрузкой или закрытием страницы (событие `beforeunload`) данные нужно сохранить

```js
function setLocalStorage() {
  localStorage.setItem("name", name.value);
}
window.addEventListener("beforeunload", setLocalStorage);
```

2. перед загрузкой страницы (событие `load`) данные нужно восстановить и отобразить

```js
function getLocalStorage() {
  const nameFromLS = localStorage.getItem("name");

  if (nameFromLS !== null) {
    name.value = nameFromLS;
  }
}
window.addEventListener("load", getLocalStorage);
```

Пояснения к коду:

- `window` - объект окна браузера, с ним связана загрузка и перезагрузка страницы
- `addEventListener` - метод, который отлавливает событие элемента и выполняет переданную функцию
- `localStorage.setItem` - метод сохраняющий данные в `localStorage`. Два параметра метода: имя значения, которое сохраняется и само значение, которое сохраняется
- `localStorage.getItem` - метод получающий данные из `localStorage`. Параметр метода - имя, под которым сохраняется значение. Возвращаемое значение - `null` или `string`.

Чтобы увидеть сохранённые в браузере данные `localStorage`, на странице приложения нажмите клавишу F12, на панели `devTools` вверху выберите пункт `Application`, на боковой панели пункт `Local Storage` и ссылку на страницу приложения.

Обратите внимание: данные в `localStorage` сохраняются в текстовом формате, например, вместо `true`, `false`, `localStorage` вернёт `"true"` и `"false"`.

#### Метод addEventListener()

В предыдущем разделе, чтобы выполнить код только после того, как изображение загрузилось, мы использовали метод `addEventListener()`. Это важный метод регистрации событий.

Событие – это сигнал от браузера о том, что что-то произошло.  
Существует много видов событий. Перечислим некоторые из них (запоминать события не нужно).

**События мыши**:

- `click` – клик
- `contextmenu` – клик правой кнопкой мыши
- `dbclick` – двойной клик
- `mouseover` – навели курсор
- `mouseout` – убрали курсор
- `mousedown` и `mouseup` – кнопку мыши нажали или отжали
- `mousemove` – движение мыши

**События клавиатуры**:

- `keydown` – кнопка нажата
- `keyup` – кнопка отжата
- `keypress` – кнопка удерживается

**События на элементах управления**:

- `focus` – элемент в фокусе, например, пользователь нажимает на input или в текстовое поле вводит текст
- `blur` – убрали мышку из фокуса
- `reset` – форма очищена
- `submit` – форма отправлена

И все эти события можно отлавливать.

Метод `addEventListener()` отлавливает событие элемента и выполняет переданную функцию.
Его синтаксис:

```js
element.addEventListener("click", () => {
  // code
});
```

- `element` – элемент на котором отлавливаем события;
- `addEventListener()` – метод отлова событий;
- `click` – какое именно событие отлавливаем (в данном случае 'клик');
- `() => {}` – функция, которая будет выполнена в тот момент, когда событие произойдёт.

Функцию, которая выполняется при наступлении события, лучше создавать отдельно, а внутри метода `addEventListener()` только указывать какая именно функция будет выполняться при наступлении данного события.

```js
element.addEventListener('click', function);
```

Обратите внимание: внутри `addEventListener()` только указываем функцию `function`, а не вызываем её `function()`

#### Ключевые навыки, которые вы приобрели:

- использование шаблонных строк
- особенности элемента `<input>`
- работа с `localStorage`
- метод `addEventListener()`
